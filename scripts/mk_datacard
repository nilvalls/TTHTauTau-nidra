#!/usr/bin/env python

"""
===================
Creating a Datacard
===================

Usage
=====
::

    mk_datacard file.root > your_data.card
    mk_datacard -o your_data.card file.root
    mk_datacard -d MyOtherFancyDiscriminant file.root
    mk_datacard -c "+my special additional categories" file.root

Note that the input ROOT file _will_ be modified!

Workflow / Customization
========================
* To add new systematics, edit `systematics.csv`
* To change categories:
  - edit the definition of `all_categories` at the very end of this file
  - use the following command-line options:
    + `-c "+my_cat1 my_cat2"` adds two new categories
    + `-c "-my_cat"` removes one category from being considered
    + `-c "my_cat1 my_cat2 my_cat3"` will only consider the three
      categories passed.
  - only save the desired categories in the input file.

Notes
=====
* Sample and discriminant names may not contain underscores (with the
  exception of the sample "data_obs")
* Indentation is four spaces
* "systematics.csv" is aligned at the delimiter "," with spaces.
  (best achieved with the `tabularized.vim` plugin)

To Do
-----
* treat categories as [(cat_name, cat_partons, cat_jets)]
* finish documentation
* doNorm
* summary of signal + background numbers for each category (stdout)

To Test
-------
* new b-tag split modes

Recently Tested
---------------
* b-tag uncertainty splitting
  * Inject b-tag uncertainties properly
  * `splitUncertainties_byCat.C`
* `copyQ2.C`
* `statUncertainties.C`
"""

import csv
import math
import os
import re
import ROOT as r
import sys

# b-tag split mode:
B_OFF = 0
B_RATE = 1      # Use rate only
B_SHAPE = 2     # Split into shape and rate
B_CAT_SHAPE = 4 # Split into shape by category and rate

# Define some regular expressions to match samples and signal.  The last
# part of the former expression is a negative look-ahead making sure that
# systematics are not caught by the category definition.
sample_re = re.compile(r'([^_]+(?:_obs)?)_([^_]+)_(.*)(?!(?:Up|Down)$)')
signal_re = re.compile(r'(ttH).*')

category_re = re.compile(r'(.*?)(?::(\d+)(?::(\d+))?)?$')

# This is the default logging instance (open file or stream)
log = sys.stderr

class IntegralException(Exception):
    """To catch integrals evaluating to zero.  `combine` does not like this
    for systematics.
    """
    pass

def get_ann_systematics(file, discriminant, categories, samples, data_sample="data_obs",
        signal_sample="ttH", is_8_tev=True):
    """For all samples and categories, this functions produces single bin
    systematics, shifts present in only one bin.  These shift will be
    produced when a process has significant expectation and the systematic
    is expected to contribute to the error.
    """
    new_sys = []

    for (c, j, p) in categories:
        data_hist = file.Get("{s}_{d}_{c}".format(s=data_sample, d=discriminant, c=c))
        sig_hist = file.Get("{s}_{d}_{c}".format(s=signal_sample + "125", d=discriminant, c=c))
        bkg_hist = None

        # Build background sum
        for (s, cats) in samples.items():
            s = s + "125" if s == "ttH" else s
            if s in (data_sample, signal_sample) or c not in cats:
                continue

            hist = file.Get("{s}_{d}_{c}".format(s=s, d=discriminant, c=c))
            if bkg_hist:
                bkg_hist.Add(hist)
            else:
                bkg_hist = hist.Clone()

        # Loop over samples for category and find low stats bins
        for (s, cats) in samples.items():
            file_s = s + "125" if s == "ttH" else s

            if c not in cats:
                continue

            hist = file.Get("{s}_{d}_{c}".format(s=file_s, d=discriminant, c=c))

            for b in range(1, hist.GetNbinsX() + 1):
                data = data_hist.GetBinContent(b)
                data_err = data_hist.GetBinError(b)

                sig = sig_hist.GetBinContent(b)
                sig_err = sig_hist.GetBinError(b)

                bkg = bkg_hist.GetBinContent(b)
                bkg_err = bkg_hist.GetBinError(b)

                val = hist.GetBinContent(b)
                val_err = hist.GetBinError(b)

                other_frac = math.sqrt(bkg_err**2 - val_err**2)

                if val < .01 or bkg_err < data_err / 3. or other_frac / bkg_err > .95 \
                        or sig / bkg < .02:
                    continue

                # FIXME Subtract 1 from bin name for comparability with
                # original C macro
                sys_name = "{s}_{c}_{e}_ANNbin{b:d}".format(
                        s=s, c=c, e="8TeV" if is_8_tev else "7TeV", b=b - 1)

                stub = "{s}_{d}_{c}_".format(s=file_s, d=discriminant, c=c)
                hist_up = hist.Clone(stub + sys_name + "Up")
                hist_up.SetBinContent(b, val + val_err)
                hist_down = hist.Clone(stub + sys_name + "Down")
                hist_down.SetBinContent(b, val - val_err)

                file.WriteObject(hist_up, hist_up.GetName())
                file.WriteObject(hist_down, hist_down.GetName())

                new_sys.append((sys_name, "shape",
                    dict([(sam, ("1" if sam == s else "-")) for sam in samples.keys()])))
    return new_sys

def get_integral(file, discriminant, category, sample="data_obs", uncertainty="", fmt="{n:.3f}", throw=False):
    """Get the integral of the histogram specified by the arguments.  The
    first argument has to be an open ROOT TFile.
    """
    if len(uncertainty) > 0:
        uncertainty = "_" + uncertainty
    h = file.Get("{s}_{d}_{c}{u}".format(s=sample, d=discriminant, c=category, u=uncertainty))
    i = h.Integral()
    if i == 0. and throw:
        raise IntegralException("The integral for {s}, {d}, {c}, {u} in {f} is zero!".format(
            s=sample, d=discriminant, c=category, u=uncertainty, f=file.GetName()))
    return fmt.format(n=h.Integral())

def get_samples(file, discriminant):
    """Reads the contents of `file`, an open ROOT TFile, and tries to
    extract available categories per sample.
    """
    samples = {}

    for k in file.GetListOfKeys():
        m = sample_re.match(k.GetName())
        if m:
            sample, disc, cat = m.groups()

            if disc != discriminant:
                continue

            m = signal_re.match(sample)
            if m:
                sample = m.group(1)

            if sample not in samples:
                samples[sample] = set()
            samples[sample].add(cat)
    return samples

def get_systematics(file, overrides={}, rename=lambda u: u, samples=False):
    """Reads `file` and returns a list of (uncertainty, type, {sample:
    value}).

    The parameter `overrides` allows to specify a dict of form
    {uncertainty: value}, and values of "x" n the systematics file are
    replaced by the one specified in the dict.

    A function passed as `rename` allows to alter the uncertainty name,
    _after_ all other processing has happened.

    The parameter `samples` can be set to `True` to obtain the available
    sample names defined in the systematics file.
    """
    reader = csv.DictReader(open(file))
    reader.fieldnames = map(str.strip, reader.fieldnames)
    sys_samples = reader.fieldnames[2:]

    if samples:
        return sys_samples

    sys = []
    for row in reader:
        unc = row.pop("Uncertainty").strip()
        type = row.pop("Type").strip()
        row = dict(map(lambda (k,v): (k, v.strip()), row.items()))
        if unc in overrides:
            row = dict(
                    map(
                        lambda (k,v): (k, overrides[unc] if v == "x" else v),
                        row.items()))
        sys.append((rename(unc), type, row))
    return sys

def split_category_string(s):
    """Split a string of form "category:jets:partons" into components.
    Returns a list of a string and two integers.
    """
    def try_conv(v):
        try:
            return int(v)
        except:
            return v
    return map(try_conv, category_re.match(s).groups())

def split_q2(file, disc, categories):
    """Split Q2-systematics by parton number as specified in `categories`,
    which is a list containing tuples of `(category, jet_multiplicity,
    partons)`.
    """
    for (c, j, p) in categories:
        for d in ("Up", "Down"):
            try:
                oldname = "ttbar_{d}_{c}_Q2scale_ttH_ttbar{dir}".format(d=disc, c=c, dir=d)
                newname = "ttbar_{d}_{c}_Q2scale_ttH_ttbar{p}p{dir}".format(d=disc, c=c, p=p, dir=d)
                hold = file.Get(oldname)
                hnew = hold.Clone(newname)
                file.WriteObject(hnew, newname)
            except:
                log.write("Can't create Q^2 scale shifts for '{c}'\n".format(c=c))

def split_systematics(file, disc, samples, btag_mode=B_CAT_SHAPE):
    """Split b-tag uncertainties:  copy category histogram w/o systematics
    for rates, systematics of form "CMS_eff_bUp" to a shape uncertainty.

    The parameter `samples` should be a dictionary containing the
    categories per sample.

    Returns a list of systematics to be injected into the systematics file.
    """
    done = set()
    new_sys = []
    r.TH1.SetDefaultSumw2()

    if btag_mode == B_OFF:
        return new_sys

    for (s, cats) in samples.items():
        s = s + "125" if s == "ttH" else s
        for c in cats:
            stub = "_".join((s, disc, c))
            orig = file.Get(stub)
            sum = orig.Integral()
            for kind in ("eff", "fake"):
                for dir in ("Up", "Down"):
                    try:
                        # Get rate uncertainty from the shape uncertainty
                        shape_old = file.Get("{s}_CMS_{k}_b{dir}".format(s=stub, k=kind, dir=dir))
                        shape_sum = shape_old.Integral()
                        rate = orig.Clone("{s}_CMS_{k}_bRate{dir}".format(s=stub, k=kind, dir=dir))
                        rate.Scale((shape_sum / sum) if sum > 0 else 1)
                        file.WriteObject(rate, rate.GetName())

                        # Treat shape uncertainties, if desired
                        if btag_mode == B_SHAPE:
                            shape = shape_old.Clone("{s}_CMS_{k}_bShape{dir}".format(s=stub, k=kind, dir=dir))
                        elif btag_mode == B_CAT_SHAPE:
                            shape = shape_old.Clone("{s}_{c}_{k}_bShape{dir}".format(s=stub, c=c, k=kind, dir=dir))
                        else:
                            continue

                        shape_sum = shape.Integral()
                        shape.Scale((sum / shape_sum) if shape_sum > 0 else 1)

                        file.WriteObject(shape, shape.GetName())
                    except:
                        log.write("Can't create b-tag shape uncertainties for '{s}'"
                                "in '{c}'\n".format(s=c, c=c))
                if btag_mode == B_SHAPE and 'all' not in done:
                    new_sys.append((
                        "CMS_{k}_bShape".format(k=kind),
                        "shape",
                        dict([(sam, "1") for sam in samples.keys()])))
                elif btag_mode == B_CAT_SHAPE and c not in done:
                    new_sys.append((
                        "{c}_{k}_bShape".format(c=c, k=kind),
                        "shape",
                        dict([(sam, "1") for sam in samples.keys()])))
            done.add('all')
            done.add(c)
    return new_sys

def write_datacard(file, discriminant, categories, cats, samples, systematics, ofile=log):
    """
    """
    filename = file.GetName()
    observed = map(
            lambda c: get_integral(file, discriminant, c, fmt="{n:.6f}"),
            map(lambda (c, j, p): c, categories))

    if "data_obs" in cats:
        del cats["data_obs"]

    bins = []
    for (n, s) in samples:
        bins += cats[s]

    sprocs = "".join(map(lambda (n, s): (" " + s) * len(cats[s]), samples))
    nprocs = "".join(map(lambda (n, s): (" " + str(n)) * len(cats[s]), samples))

    rates = ["-1"] * len(cats["ttH"])
    for (n, s) in samples[1:]:
        for c in cats[s]:
            rates.append(str(get_integral(file, discriminant, c, s, fmt="{n:.6}")))

    # Print preamble
    ofile.write("""imax * # number of channels
jmax * # number of backgrounds
kmax * # number of nuisance parameters
---------------
bin {c}
observation {o}
---------------
shapes * * {f} $PROCESS_{d}_$CHANNEL $PROCESS_{d}_$CHANNEL_$SYSTEMATIC
shapes ttH * {f} $PROCESS$MASS_{d}_$CHANNEL $PROCESS$MASS_{d}_$CHANNEL_$SYSTEMATIC
---------------
bin {bs}
process {ps}
process {ns}
rate {rs}
---------------
""".format(
    c=" ".join(map(lambda (c, j, p): c, categories)),
        o=" ".join(map(str, observed)),
        d=discriminant,
        f=filename,
        bs=" ".join(bins),
        ps=sprocs,
        ns=nprocs,
        rs=" ".join(rates)))

    active_unc = []
    for (unc, type, vals) in systematics:
        active = False

        ofile.write("{u} {t}".format(u=unc, t=type))
        for (n, s) in samples:
            file_s = s + "125" if s == "ttH" else s
            for c in cats[s]:
                if type == "shape" and vals[s] != "-":
                    try:
                        get_integral(file, discriminant, c, file_s, unc + "Up", throw=True)
                        get_integral(file, discriminant, c, file_s, unc + "Down", throw=True)
                        ofile.write(" " + vals[s])
                        active = True
                    except IntegralException, e:
                        ofile.write(" -")
                        # Print for everything _except_ for b-tag shape or ANN
                        # uncertainties with inappropriate category
                        if not (not unc.startswith(c) and ("bShape" in unc or "ANNbin" in unc)):
                            log.write("Integral zero for {s}, {c}, {u}: disabling "
                                    "systematics\n".format(s=s, c=c, u=unc))
                    except:
                        ofile.write(" -")
                        if not (not unc.startswith(c) and ("bShape" in unc or "ANNbin" in unc)):
                            log.write("Integral not available for {s}, {c}, {u}: disabling "
                                    "systematics\n".format(s=s, c=c, u=unc))
                elif vals[s] in ["-", "1"] and not \
                        (unc == "Q2scale_ttH_V" and s in ("wjets", "zjets")):
                    ofile.write(" " + vals[s])
                    if vals[s] == "1":
                        active = True
                else:
                    if unc == "Q2scale_ttH_V" and s in ("wjets", "zjets"):
                        try:
                            mult = filter(lambda (cat, j, p): cat == c, categories)[0][1]
                            vals[s] = str(1 + .1 * mult)
                        except:
                            ofile.write(" -")
                            continue

                    active = True
                    new_val = math.e ** (math.sqrt(math.log(1 + (float(vals[s]) - 1)**2)))
                    ofile.write(" {n:.3f}".format(n=new_val))
        ofile.write("\n")

        if active:
            active_unc.append(unc)

    ofile.write("---------------\n")
    return active_unc

def create_datacard(ifile, ofile, disc, all_categories,
        disabled_systematics=[], btag_mode=B_CAT_SHAPE,
        print_summary=False):
    """Create a datacard for `ifile` (an open ROOT file) using the
    discriminant `disc` and categories, jet multiplicities, parton counts
    defined in `all_categories`.
    """
    sysfile = os.path.join(os.path.dirname(__file__), "systematics.csv")
    all_category_names = map(lambda (c, j, p): c, all_categories)

    is_8_tev = True
    def rename(unc):
        if unc == "lumi":
            return unc + "_8TeV" if is_8_tev else unc + "_7TeV"
        return unc

    # This replaces "x" in the systematics csv file with the values specified
    # for certain uncertainties
    overrides = {
            "lumi": "1.044" if is_8_tev else "1.022",
            "CMS_ttH_eff_lep": "1.04" if is_8_tev else "1.018",
            "CMS_ttH_QCDscale_ttbb": "1.5"}

    # Retrieve list of samples (ordered) from systematics file
    samples = get_systematics(sysfile, samples=True)

    # Get available categories for every sample
    all_samples = get_samples(ifile, disc)

    # Trim previous to the samples defined in the systematics file and filter
    # categories to the ones defined above
    cats = dict(map(
            lambda (k, cs): (k, filter(lambda c: c in cs, all_category_names)),
            filter(
                lambda (k, cs): k in samples,
                all_samples.items())))

    # Enumerate samples for combine
    # nums = dict([(s, n) for (n, s) in enumerate(samples)])
    samples = enumerate(samples)

    systematics = get_systematics(sysfile, overrides=overrides, rename=rename)
    all_uncertainties = map(lambda (u, t, vs): u, systematics)
    systematics = filter(lambda (u, t, vs): u not in disabled_systematics, systematics)
    systematics += split_systematics(ifile, disc, cats, btag_mode)
    systematics += get_ann_systematics(ifile, disc, all_categories, cats, is_8_tev=is_8_tev)

    new_cats = set()
    for (s, cs) in cats.items():
        for c in cs:
            new_cats.add(c)
    new_cats = list(new_cats)
    categories = filter(lambda (c, j, p): c in new_cats, all_categories)

    # keep only essential samples
    samples = filter(lambda (n, s): s in cats, samples)

    split_q2(ifile, disc, all_categories)

    active_unc = write_datacard(ifile, disc, categories, cats, samples, systematics,
            ofile=ofile)

    if not print_summary:
        return

    category_names = map(lambda (c, j, p): c, categories)

    cstring = " ".join(map(lambda c: c if c in category_names else "[" + c + "]",
        all_category_names)).replace("] [", " ")
    sstring = " ".join(map(lambda (n, s): s if s in all_samples.keys() else "[" + s + "]",
        samples)).replace("] [", " ")
    ustring = " ".join(map(lambda u: u if u in active_unc else "[" + u + "]",
        all_uncertainties)).replace("] [", " ")

    log.write("""
Executive Summary
=================

Included in Datacard
--------------------
Categories:    {cs}
Samples:       {ss}
Uncertainties: {us}
~~~
Disabled objects present within []s
""".format(cs=cstring, ss=sstring, us=ustring))

if __name__ == '__main__':
    r.gROOT.SetBatch()

    import optparse

    # This has the format "category:jet_multiplicity:partons" where the
    # latter two are optional.
    all_categories = map(split_category_string,
            "ljets_j4_t3:4:0 ljets_j4_t4:4:0 ljets_j5_t3:5:1 ljets_j5_tge4:5:1 " \
            "ljets_jge6_t2:6:2 ljets_jge6_t3:6:2 ljets_jge6_tge4:6:2 " \
            "ge3t:3:1 e3je2t:3:1 ge4je2t:4:2 " \
            "SS_ge4je1t:4:1 SS_e3jge2t:3:0 SS_ge4jge2t:3:1 " \
            "TTL_j2_t1:2 TTL_j2_t2:2 TTL_j3_t1:3 " \
            "TTL_jge4_t1 TTL_j3_t2 TTL_jge4_t2".split())

    parser = optparse.OptionParser(usage="%prog [options] file")
    parser.add_option("-d", "--discriminant", dest="disc",
            help="use DISC as discriminant", metavar="DISC",
            default="CFMlpANN")
    parser.add_option("-o", "--outfile", dest="ofile",
            help="write datacard to FILE", metavar="FILE")
    parser.add_option("-c", "--categories", dest="categories",
            help="use CATS for possible categories (separated by whitespace).  "
            "A leading `+` adds to the default, a leading `-` removes.",
            metavar="CATS")
    parser.add_option("-s", "--disable-systematic", dest="nosys",
            help="disable uncertainties in SYS (separated by whitespace).",
            metavar="SYS", default="")
    parser.add_option("-b", "--btag-mode", dest="btag",
            help="set b-tag uncertainty treatment to MODE.  (Allowed "
            "values: off, rate, shape, category)", metavar="MODE",
            default="category")

    (opts, args) = parser.parse_args()

    if len(args) != 1:
        parser.error("need to specify input file")

    if opts.btag == "off":
        btag_mode = B_OFF
    elif opts.btag == "rate":
        btag_mode = B_RATE
    elif opts.btag == "shape":
        btag_mode = B_SHAPE
    elif opts.btag == "category":
        btag_mode = B_CAT_SHAPE
    else:
        parser.error("invalid b-tag mode: " + opts.btag)

    if not opts.ofile:
        ofile = sys.stdout
    else:
        ofile = open(opts.ofile, 'w')

    if opts.categories:
        if opts.categories.startswith("+"):
            categories = all_categories + map(split_category_string, opts.categories[1:].split())
        elif opts.categories.startswith("-"):
            categories = all_categories
            disabled = map(lambda (c, j, p): c, map(split_category_string, opts.categories[1:].split()))
            categories = filter(lambda (c, j, p): c not in disabled, categories)
        else:
            categories = map(split_category_string, opts.categories.split())
    else:
        categories = all_categories

    f = r.TFile(args[0], "UPDATE")
    create_datacard(f, ofile, opts.disc, categories,
            disabled_systematics=opts.nosys.split(),
            btag_mode=btag_mode, print_summary=True)
